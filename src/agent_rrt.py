import MalmoPython
import math
import sys
import time
import random

class Agent(object):

    def __init__(self, start, goal, alpha, beta, charlie, max_nodes, int_steps):
        """
        Creates an agent instance.
        :param start: The starting position of the agent.
        :param goal: The goal position of the agent.
        :param alpha: The probability of sampling using line-to.
        :param beta: The probability of sampling using ellipsoid.
        :param charlie: The probability of sampling the goal.
        :param max_nodes: The maxmimum amount of nodes generated by the agent.
        """
        self.start = start
        self.goal = goal
        self.alpha = alpha
        self.beta = beta
        self.charlie = charlie
        self.max_nodes = max_nodes
        self.int_steps = int_steps

    def get_start(self):
        """
        Gets the starting position of the agent.
        :return: A tuple (x, y, z) containing the starting position of the agent.
        """
        return self.start

    def get_goal(self):
        """
        Gets the goal position of the agent.
        :return: A tuple (x, y, z) containing the goal position of the agent.
        """
        return self.goal

    def get_alpha(self):
        """
        Gets the probability of sampling using line-to.
        :return: A probability p | 0 <= p <= 1.
        """
        return self.alpha

    def get_beta(self):
        """
        Gets the probability of sampling using ellipsoid.
        :return: A probability p | 0 <= p <= 1.
        """
        return self.beta

    def get_charlie(self):
        """
        Gets the probability of sampling the goal.
        :return: A probability p | 0 <= p <= 1.
        """
        return self.charlie

    def get_max_nodes(self):
        """
        Gets the maximum amount of nodes the agent is allowed to generate.
        :return: An integer x | x > 0.
        """
        return self.max_nodes

    def get_int_steps(self):
        """
        Gets the amount of steps taken when interpolating.
        :return: An integer x | x > 0.
        """
        return self.int_steps

    @staticmethod
    def distance(p1, p2):
        """
        Calculates the distance between two points in euclidean three space.
        :param p1: A tuple (x, y, z).
        :param p2: A tuple (x, y, z).
        :return: The euclidean distance between p1 and p2.
        """
        return math.sqrt(((p2[0] - p1[0]) * (p2[0] - p1[0])) +
                         ((p2[1] - p1[1]) * (p2[1] - p1[1])) +
                         ((p2[2] - p1[2]) * (p2[2] - p1[2])))

    def ellipsoid(self, p, xr=3.0, yr=3.0, zr=3.0):
        """
        Samples a point from the ellipsoidal search region around point p.
        :param p: A tuple (x, y, z).
        :param xr: A float x | x >= 1.0
        :param yr: A float x | x >= 1.0
        :param zr: A float x | x >= 1.0
        :return: A tuple (x, y, z).
        """
        def inside(x, y, z):
            """
            Determines if a set of coordinates fall within the ellipsoidal search region.
            :param x: An integer x | worlds minimum x dimension <= x < worlds maximum x dimension.
            :param y: An integer t | worlds minimum y dimension <= y < worlds maximum y dimension..
            :param z: An integer z | worlds minimum z dimension <= z < worlds maximum z dimension.
            :return: True if the coordinate falls within the ellipsoidal search region, False otherwise.
            """
            return (((x-p[0])/xr)*((x-p[0])/xr) +
                    ((y-p[1])/yr)*((y-p[1])/yr) +
                    ((z-p[2])/zr)*((z-p[2])/zr)) < 1
        raise NotImplementedError

    @staticmethod
    def interpolate(p1, p2, t):
        """

        :param p1:
        :param p2:
        :param t:
        :return:
        """
        return ((1 - t) * (p1[0] + (t * p2[0])),
                (1 - t) * (p1[1] + (t * p2[1])),
                (1 - t) * (p1[2] + (t * p2[2])))

    def line_to(self, p1, p2):
        """

        :param p1:
        :param p2:
        :return:
        """
        raise NotImplementedError

class Node(object):

    def __init__(self, position, parent=None):
        self.position = position
        self.parent = parent

    def get_parent(self):
        return self.parent

    def get_position(self):
        return self.position

    def set_position(self, position):
        self.position = position

class Obstacle(object):

    _obstacle_id = 0

    def __init__(self, xdims, ydims, zdims):
        self.xdims = xdims
        self.ydims = ydims
        self.zdims = zdims
        self.obstacle_id = Obstacle._obstacle_id
        Obstacle._obstacle_id += 1

    def __eq__(self, other):
        return self.obstacle_id == other.obstacle_id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.obstacle_id)

    def get_xmin(self):
        return min(self.xdims)

    def get_xmax(self):
        return max(self.xdims)

    def get_ymin(self):
        return min(self.ydims)

    def get_ymax(self):
        return max(self.ydims)

    def get_zmin(self):
        return min(self.zdims)

    def get_zmax(self):
        return max(self.zdims)

    def inside(self, p):
        return (self.get_xmin() <= p[0] < self.get_xmax() and
                self.get_ymin() <= p[1] < self.get_ymax() and
                self.get_zmin() <= p[2] < self.get_zmax())

class World(object):

    def __init__(self, xdims, ydims, zdims):
        """
        Creates a world instance.
        :param xdims: The x dimensions of the world.
        :param ydims: The y dimensions of the world.
        :param zdims: The z dimensions of the world.
        """
        self.xdims = xdims
        self.ydims = ydims
        self.zdims = zdims
        self.obstacles = set()

    def get_xmin(self):
        """
        Gets the minimum x dimension of the world.
        :return: An integer x | x < max(x dimensions).
        """
        return min(self.xdims)

    def get_xmax(self):
        """
        Gets the maximum y dimension of the world.
        :return: An integer y | y > min(y dimensions).
        """
        return max(self.xdims)

    def get_ymin(self):
        """
        Gets the minimum z dimension of the world.
        :return: An integer z | z < max(z dimensions).
        """
        return min(self.ydims)

    def get_ymax(self):
        """
        Gets the maximum x dimension of the world.
        :return: An integer x | x > min(x dimensions).
        """
        return max(self.ydims)

    def get_zmin(self):
        """
        Gets the minimum y dimension of the world.
        :return: An integer y | y < max(y dimensions).
        """
        return min(self.zdims)

    def get_zmax(self):
        """
        Gets the maximum z dimension of the world.
        :return: An integer z | z > min(z dimensions).
        """
        return max(self.zdims)

    def in_bounds(self, p):
        """
        Determines if a point is inside the world.
        :param p: A tuple (x, y, z).
        :return: True if the point is within the world, False otherwise.
        """
        return (self.get_xmin() <= p[0] < self.get_xmax() and
                self.get_ymin() <= p[1] < self.get_ymax() and
                self.get_zmin() <= p[2] < self.get_zmax())

    def is_blocked(self, p):
        """
        Determines if a point is inside an obstacle.
        :param p: A tuple (x, y, z).
        :return: True if the point is within an obstacle in the world, False otherwise.
        """
        for obstacle in self.obstacles:
            if obstacle.inside(p):
                return True
        return False

    def is_valid(self, p):
        """
        Determines if a point is valid such that it is in bounds and outside an obstacle.
        :param p: A tuple (x, y, z).
        :return: True if the point is valid, False otherwise.
        """
        return self.in_bounds(p) and not self.is_blocked(p)

    def is_walkable(self, p):
        """
        Determines if a point is walkable or not. A point p is walkable if it rests on an obstacle and does not intersect with obstacles one or two units above it.
        :param p: A tuple (x, y, z).
        :return: Trus if the point is valid, False otherwise.
        """
        raise NotImplementedError

def malmo():
    raise NotImplementedError

if __name__ == '__main__':
    malmo()