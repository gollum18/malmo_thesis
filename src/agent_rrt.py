# Name: agent_rrt.py
# Since: 08/21/2017
# Modified: 10/05/2017
# Description: Defines an agent that traverses three dimensional space using a rapidly exploring random tree.

from __future__ import division
import MalmoPython
import json
import math
import sys
import time
import random
from Queue import PriorityQueue

#
# Program Constants
#

mission_files = ('./missions/pp_maze_one.xml',
                 './missions/pp_maze_two.xml',
                 './missions/pp_maze_three.xml',
                 './missions/pp_maze_four.xml')
mission_text_files = ('./missions/pp_maze_one.txt',
                      './missions/pp_maze_two.txt',
                      './missions/pp_maze_three.txt',
                      './missions/pp_maze_four.txt')
mission_lower_bounds = ((-24, 55, -24), (-24, 55, -24), (-25, 53, -24), (-24, 55, -24))
mission_upper_bounds = ((26, 70, 25), (25, 70, 25), (25, 70, 25), (25, 70, 25))
mission_start = (0.5, 56, 24.5)
mission_goal = ((0.5, 56, -23.5), (0.5, 58, -23.5), (0.5, 54, -23.5), (0.5, 56, 0.5))

#
# Utility Functions
#
def round_point(p):
    def r(n):
        return round(n*2) / 2
    return r(p[0]), r(p[1]), r(p[2])

#
# Program Classes
#

class Agent(object):

    def __init__(self, start, goal, alpha=0.05, beta=3.25, max_nodes=5000, max_distance=7.0, planning_time=.25):
        """
        Creates an agent instance.
        :param start: The starting position of the agent.
        :param goal: The goal position of the agent.
        :param alpha: The probability of sampling the goal.
        :param beta: The probability of sampling using ellipsoid.
        :param max_nodes: The maximum amount of nodes generated by the agent.
        :param max_distance: The max distance between nodes in line-to.
        :param planning_time: The amount of time allotted for path planning.
        """
        self.start = start
        self.goal = goal
        self.alpha = alpha
        self.beta = beta
        self.max_nodes = max_nodes
        self.max_distance = max_distance
        self.planning_time = planning_time
        self.world = None
        self.traversed = set()

    def get_start(self):
        """
        Gets the starting position of the agent.
        :return: A tuple (x, y, z) containing the starting position of the agent.
        """
        return self.start

    def get_goal(self):
        """
        Gets the goal position of the agent.
        :return: A tuple (x, y, z) containing the goal position of the agent.
        """
        return self.goal

    def get_alpha(self):
        """
        Gets the probability of sampling the goal.
        :return: A probability p | 0 <= p <= 1.
        """
        return self.alpha

    def get_beta(self):
        """
        Gets the probability of sampling using ellipsoid.
        :return: A probability p | 0 <= p <= 1.
        """
        return self.beta

    def get_max_nodes(self):
        """
        Gets the maximum amount of nodes the agent is allowed to generate.
        :return: An integer x | x > 0.
        """
        return self.max_nodes

    def create_world(self, xdims, ydims, zdims, filename):
        """
        Initializes the world with obstacles and walkable space.
        :param xdims: The x dimensions of the world.
        :param ydims: The y dimensions of the world.
        :param zdims: The z dimensions of the world.
        :param filename: The name of the file containing all obstacles and walkable space.
        :return: N/A
        """
        if not xdims or not ydims or not zdims or not filename:
            raise ValueError
        reader = open(filename, 'r')
        if not reader:
            raise IOError
        # Create a world state
        self.world = World(xdims, ydims, zdims)
        # Read in obstacle information from file.
        ignoring = False
        for line in reader.readlines():
            line = line.strip("\n")
            if line.startswith("/*") and not ignoring:
                ignoring = True
                continue
            if line.endswith("*/") and ignoring:
                ignoring = False
                continue
            if not ignoring:
                if line.startswith("//") or not line:
                    continue
                parts = [int(part) for part in line.split()]
                self.world.add_obstacle((parts[0], parts[1]), (parts[2], parts[3]), (parts[4], parts[5]))
        reader.close()
        # Begin flood filling from the start to initialize walkable space.
        prospective = [self.start]
        evaluated = set()
        while prospective:
            current = prospective.pop(0)
            for neighbor in self.generate_neighbors(current):
                if neighbor in prospective or neighbor in evaluated:
                    continue
                prospective.append(neighbor)
            evaluated.add(current)
            self.world.add_walkable(current)

    @staticmethod
    def cost(n1, n2):
        """
        Determines the cost of moving from one node to the next.
        :param n1: The source node.
        :param n2: The destination node.
        :return: The cost of moving from the source nde to the destination node.
        """
        return 1 + math.fabs(n1.get_position()[1]-n2.get_position()[1])

    @staticmethod
    def distance(p1, p2):
        """
        Calculates the distance between two points in either 2D or 3D.
        :param p1: A tuple (x, y) or a tuple (x, y, z).
        :param p2: A tuple (x, y) or a tuple (x, y, z).
        :return: The distance between the two points.
        """
        def dist2(p1, p2):
            """
            Calculates the distance between two points in either 2D.
            :param p1: A tuple (x, y).
            :param p2: A tuple (x, y).
            :return:
            """
            return math.sqrt(
                (p1[0] - p2[0]) * (p1[0] - p2[0]) +
                (p1[1] - p2[1]) * (p1[1] - p2[1]))

        def dist3(p1, p2):
            """
            Calculates the distance between two points in either 3D.
            :param p1: A tuple (x, y, z).
            :param p2: A tuple (x, y, z).
            :return:
            """
            return math.sqrt(
                (p1[0] - p2[0]) * (p1[0] - p2[0]) +
                (p1[1] - p2[1]) * (p1[1] - p2[1]) +
                (p1[2] - p2[2]) * (p1[2] - p2[2]))

        if len(p1) == 2 and len(p2) == 2:
            return dist2(p1, p2)
        elif len(p1) == 3 and len(p2) == 3:
            return dist3(p1, p2)
        else:
            raise ValueError

    @staticmethod
    def midpoint(p1, p2):
        """
        Determines all of the points that lie on the line defined by p1 and p2 using the midpoint formula.
        :param p1: A tuple (x, y) or a tuple (x, y, z).
        :param p2: A tuple (x, y) or a tuple (x, y, z).
        :return:
        """
        def midpoint2(p1, p2):
            """
            Determines all of the points that lie on the line defined by p1 and p2 using the midpoint formula.
            :param p1: A tuple (x, y).
            :param p2: A tuple (x, y).
            :return:
            """
            if Agent.distance(p1, p2) <= 1:
                return []
            m = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)
            return [m] + midpoint2(p1, m) + midpoint2(m, p2)

        def midpoint3(p1, p2):
            """
            Determines all of the points that lie on the line defined by p1 and p2 using the midpoint formula.
            :param p1: A tuple (x, y, z).
            :param p2: A tuple (x, y, z).
            :return:
            """
            if Agent.distance(p1, p2) <= 1:
                return []
            m = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2)
            return [m] + midpoint3(p1, m) + midpoint3(m, p2)

        if len(p1) == 2 and len(p2) == 2:
            return midpoint2(p1, p2)
        elif len(p1) == 3 and len(p2) == 3:
            return midpoint3(p1, p2)
        else:
            raise ValueError

    def ellipsoid(self, p, xr=3.0, yr=3.0, zr=3.0):
        """
        Samples a point from the ellipsoidal search region around point p.
        :param p: A tuple (x, y, z).
        :param xr: A float x | x >= 1.0
        :param yr: A float x | x >= 1.0
        :param zr: A float x | x >= 1.0
        :return: A tuple (x, y, z).
        """
        def inside(x, y, z):
            """
            Determines if a set of coordinates fall within the ellipsoidal search region.
            :param x: An integer x | worlds minimum x dimension <= x < worlds maximum x dimension.
            :param y: An integer t | worlds minimum y dimension <= y < worlds maximum y dimension..
            :param z: An integer z | worlds minimum z dimension <= z < worlds maximum z dimension.
            :return: True if the coordinate falls within the ellipsoidal search region, False otherwise.
            """
            return (((x-p[0])/xr)*((x-p[0])/xr) +
                    ((y-p[1])/yr)*((y-p[1])/yr) +
                    ((z-p[2])/zr)*((z-p[2])/zr)) < 1
        space = set()
        for p in self.world.get_walkables():
            if inside(*p):
                space.add(p)
        # Get the point inside the ellipsoid that is closest to the goal
        p = None
        d = float("inf")
        for pt in space - self.traversed:
            t = self.distance(pt, self.goal)
            if t < d:
                p = pt
                d = t
        return p

    def explore_astar(self):
        """
        Explores the search space using A* search.
        :return: A list containing the path, or [] if there is no path.
        """
        prospective = PriorityQueue()
        prospective.put_nowait((0.0, Node(self.start)))
        evaluated = set()
        while not prospective.empty():
            current = prospective.get_nowait()[1]
            if self.is_goal(current.get_position()):
                return self.reconstruct_path(current)
            if current.get_position() not in evaluated:
                for neighbor in self.generate_neighbors(current.get_position()):
                    node = Node(neighbor, current)
                    node.set_gscore(Agent.cost(current, node) + current.get_gscore())
                    node.set_hscore(Agent.heuristic(node))
                    node.set_fscore(node.get_gscore() + node.get_fscore())
                    prospective.put_nowait((node.get_fscore(), node))
        return []

    def explore_rrt(self):
        """
        Finds a path using a rapidly exploring random tree.
        :return: A list containing the path, or [] if there is no path.
        """
        # Come up with the tree algorithm for this
        nodes = [Node(self.start)]
        for i in range(self.max_nodes):
            # Shamelessly borrowed from Steven M. Lavalles Implementation of RRT
            rand = self.uniform()
            nn = nodes[0]
            for node in nodes:
                if self.distance(node.get_position(), rand) < self.distance(nn.get_position(), rand):
                    nn = node
            nodes.append(Node(self.sample(nn.get_position(), rand), nn))
            self.traversed.add(nodes[-1].get_position())
            #print nodes[-1].get_position(), " == ",  self.goal, " is: ", self.is_goal(nodes[-1].get_position())
            if self.is_goal(nodes[-1].get_position()):
                return self.reconstruct_path(nodes[-1])
        return []

    def generate_neighbors(self, p):
        """
        Generates all possible neighbors that are one (1) unit away from the given point p.
        :param p: A tuple (x, y, z).
        :return: A list containing all the neighbors of point p that have not already been seen or evaluated.
        """
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                for dz in [-1, 0, 1]:
                    # Do not want the current location
                    if dx == 0 and dy == 0 and dz == 0:
                        continue
                    n = p[0] + dx, p[1] + dy, p[2] + dz
                    # Check to see if the point lies on an obstacle
                    if self.world.is_traversable(n):
                        neighbors.append(n)
        return neighbors

    @staticmethod
    def heuristic(n):
        """
        Tries to determine an optimal heuristic for a multi-leveled search problem.
        :param n: The node to determine the heuristic for.
        :return: The estimated distance to the goal.
        """
        # TODO: Implement the heuristic so it biases reaching the same level as the goal and discourages
        #   TODO: staying on levels that are not the goal.
        #   TODO: Right now it simply returns the null heuristic;
        #   TODO: this encourages behavior similar to Dijkstras algorithm.
        return 0

    def is_goal(self, p):
        """
        Determines if a point meets the goal conditions.
        :param p: A tuple (x, y, z).
        :return: True if a point meets the goal conditions, False otherwise.
        """
        return (self.goal[0] - .5 <= p[0] < self.goal[0] + .5 and
                self.goal[1] == p[1] and
                self.goal[2] - .5 <= p[2] < self.goal[2] + .5)

    def line_of_sight(self, p1, p2):
        """
        Determines line of sight from p1 to p2.
        :param p1: A tuple (x, y, z).
        :param p2: A tuple (x, y, z).
        :return: True if there is line of sight between p1 and p2, False otherwise.
        """
        for point in Agent.midpoint(p1, p2):
            if not self.world.is_valid(point):
                return False
        return True

    def line_to(self, p1, p2):
        """
        Samples a point along the line p1->p2.
        :param p1: A tuple (x, y, z).
        :param p2: A tuple (x, y, z).
        :return: A tuple (x, y, z).
        """
        # Check to see if the randomly sampled point is close enough
        if self.distance(p1, p2) < self.max_distance:
            # Get the list of all points on the line
            nodes = Agent.midpoint(p1, p2)
            # Round them all down
            for i in range(len(nodes)):
                nodes[i] = (nodes[i][0], math.floor(nodes[i][1]), nodes[i][2])
            # Filter out any that are not walkable
            nodes = [node for node in nodes if self.world.is_walkable(node)]
            nodes.append(p2)
            # Pick one that was not already used
            return random.sample(set(nodes)-self.traversed, 1)[0]
        # If it is not, then sample randomly from points that are close enough
        else:
            return self.ellipsoid(p1, xr=self.max_distance, zr=self.max_distance)

    def reconstruct_path(self, node):
        """
        Reconstructs a path from a node.
        :param node: The reached goal node.
        :return: The path from the start node to the goal node.
        """
        path = []
        while node.get_parent():
            path.append(node.get_position())
            node = node.get_parent()
        return path

    def sample(self, p1, p2):
        p = random.random()
        if p > 1-self.alpha:
            return self.line_to(p1, p2)
        elif p <= (1-self.alpha)/self.beta or not self.line_of_sight(p1, p2):
            return self.uniform()
        else:
            return self.ellipsoid(p1, 3.0, 1.25, 3.0)

    def uniform(self):
        """
        Uniformly samples a point from walkable space.
        :return: A tuple (x, y, z).
        """
        return random.sample(self.world.get_walkables() - self.traversed, 1)[0]


class Node(object):

    def __init__(self, position, parent=None, fscore=0.0, gscore=0.0, hscore=0.0):
        """
        Creates an instance of a node object.
        :param position: The position of this node.
        :param parent: Optional. The parent of this node.
        :param fscore: Optional. How viable is this node? The gscore + hscore.
        :param gscore: Optional. The accumulated distance so far.
        :param hscore: Optional. The estimated distance from this node to the goal.
        """
        self.position = position
        self.parent = parent
        self.fscore = fscore
        self.gscore = gscore
        self.hscore = hscore

    def get_parent(self):
        """
        Gets the parent node of this node.
        :return: A node object or None if it does not have a parent.
        """
        return self.parent

    def set_parent(self, parent):
        """
        Sets the parent of this node.
        :param parent: Reference to the new parent node.
        :return: N/A
        """
        self.parent = parent

    def get_position(self):
        """
        Gets the position of this node.
        :return: A tuple (x, y, z).
        """
        return self.position

    def get_fscore(self):
        """
        Gets the fscore of this node.
        :return: A float.
        """
        return self.fscore

    def set_fscore(self, score):
        """
        Sets the fscore for this node.
        :param score:
        :return: N/A
        """
        self.fscore = score

    def get_gscore(self):
        """
        Gets the gscore of this node.
        :return: A float.
        """
        return self.gscore

    def set_gscore(self, score):
        """
        Sets the gscore for this node.
        :param score:
        :return: N/A
        """
        self.gscore = score

    def get_hscore(self):
        """
        Gets the hscore of this node.
        :return: A float.
        """
        return self.hscore

    def set_hscore(self, score):
        """
        Sets the hscore for this node.
        :param score: The new hscore for this node.
        :return: N/A
        """
        self.hscore = score

class Obstacle(object):

    _obstacle_id = 0

    def __init__(self, xdims, ydims, zdims):
        """
        Creates an instance of an obstacle object.
        :param xdims: The x dimensions of the object.
        :param ydims: The y dimensions of the object.
        :param zdims: The z dimensions of the object.
        """
        self.xdims = xdims
        self.ydims = ydims
        self.zdims = zdims
        self.obstacle_id = Obstacle._obstacle_id
        Obstacle._obstacle_id += 1

    def __eq__(self, other):
        """
        Determines if this obstacle is equal to another.
        :param other: The other obstacle to compare against.
        :return: True if the obstacles share the same obstacle ID, False otherwise.
        """
        return self.obstacle_id == other.obstacle_id

    def __ne__(self, other):
        """
        Determines if this obstacle is not equal to another.
        :param other: The other obstacle to compare against.
        :return: True if the obstacles do not share the same obstacle ID, False otherwise.
        """
        return not self.__eq__(other)

    def __hash__(self):
        """
        Creates a hash for this obstacle.
        :return: An integer.
        """
        return hash(self.obstacle_id)

    def get_xmin(self):
        """
        Gets the minimum x dimension of this obstacle.
        :return: An integer.
        """
        return min(self.xdims)

    def get_xmax(self):
        """
        Gets the maximum x dimension of this obstacle.
        :return: An integer.
        """
        return max(self.xdims)

    def get_ymin(self):
        """
        Gets the minimum y dimension of this obstacle.
        :return: An integer.
        """
        return min(self.ydims)

    def get_ymax(self):
        """
        Gets the maximum y dimension of this obstacle.
        :return: An integer.
        """
        return max(self.ydims)

    def get_zmin(self):
        """
        Gets the minimum z dimension of this obstacle.
        :return: An integer.
        """
        return min(self.zdims)

    def get_zmax(self):
        """
        Gets the maximum z dimenison of this obstacle.
        :return: An integer.
        """
        return max(self.zdims)

    def set_xdims(self, xdims):
        """
        Sets the x dimensions of the world.
        :param xdims: A tuple (min-x, max-x)
        :return: N/A
        """
        self.xdims = xdims

    def set_ydims(self, ydims):
        """
        Sets the y dimensions of the world.
        :param ydims: A tuple (min-y, max-y)
        :return: N/A
        """
        self.ydims = ydims

    def set_zdims(self, zdims):
        """
        Sets the z dimensions of the world.
        :param zdims: A tuple (min-z, max-z)
        :return: N/A
        """
        self.zdims = zdims

    def inside(self, p):
        """
        Determines if a point lies inside this obstacle.
        :param p: A tuple (x, y, z).
        :return: True if the point lies inside the obstacle, False otherwise.
        """
        return (self.get_xmin() <= p[0] < self.get_xmax() and
                self.get_ymin() <= p[1] < self.get_ymax() and
                self.get_zmin() <= p[2] < self.get_zmax())

    def ontop(self, p):
        """
        Determines if a point is on top of the obstacle or not.
        :param p: A tuple (x, y, z).
        :return: True if the point is on top of the obstacle, False otherwise.
        """
        return (self.get_xmin() <= p[0] < self.get_xmax() and
                p[1] == self.get_ymax() and
                self.get_zmin() <= p[2] < self.get_zmax())

class StopWatch(object):

    def __innit__(self):
        self.current = time.time()

    def elapsed(self):
        return time.time() - self.current

    def reset(self):
        self.current = time.time()

class World(object):

    def __init__(self, xdims, ydims, zdims):
        """
        Creates a world instance.
        :param xdims: The x dimensions of the world.
        :param ydims: The y dimensions of the world.
        :param zdims: The z dimensions of the world.
        """
        self.xdims = xdims
        self.ydims = ydims
        self.zdims = zdims
        self.obstacles = set()
        self.walkable = dict()

    def get_xmin(self):
        """
        Gets the minimum x dimension of the world.
        :return: An integer x | x < max(x dimensions).
        """
        return min(self.xdims)

    def get_xmax(self):
        """
        Gets the maximum y dimension of the world.
        :return: An integer y | y > min(y dimensions).
        """
        return max(self.xdims)

    def get_ymin(self):
        """
        Gets the minimum z dimension of the world.
        :return: An integer z | z < max(z dimensions).
        """
        return min(self.ydims)

    def get_ymax(self):
        """
        Gets the maximum x dimension of the world.
        :return: An integer x | x > min(x dimensions).
        """
        return max(self.ydims)

    def get_zmin(self):
        """
        Gets the minimum y dimension of the world.
        :return: An integer y | y < max(y dimensions).
        """
        return min(self.zdims)

    def get_zmax(self):
        """
        Gets the maximum z dimension of the world.
        :return: An integer z | z > min(z dimensions).
        """
        return max(self.zdims)

    def get_obstacles(self):
        """
        Gets a list containing all the obstacles.
        :return: A list containing all obstacles.
        """
        return self.obstacles

    def get_walkables(self):
        """
        Gets a set containing all walkable space.
        :return: A set containing all walkable space.
        """
        walkable = set()
        for y in self.walkable.keys():
            for x, z in self.walkable[y]:
                walkable.add((x, y, z))
        return walkable

    def add_obstacle(self, xdims, ydims, zdims):
        """
        Adds an obstacle to the world.
        :param xdims: A tuple (min-x, max-x).
        :param ydims: A tuple (min-y, max-y).
        :param zdims: A tuple (min-z, max-z).
        :return: N/A
        """
        self.obstacles.add(Obstacle(xdims, ydims, zdims))

    def add_walkable(self, p):
        """
        Adds a walkable point to the world.
        :param p: A tuple (x, y, z).
        :return: N/A
        """
        if p[1] in self.walkable.keys():
            self.walkable[p[1]].add((p[0], p[2]))
        else:
            self.walkable[p[1]] = set()
            self.walkable[p[1]].add((p[0], p[2]))

    def empty(self):
        """
        Clears this worlds obstacles and walkable space.
        :return: N/A
        """
        self.obstacles.clear()
        self.walkable.clear()

    def in_bounds(self, p):
        """
        Determines if a point is inside the world.
        :param p: A tuple (x, y, z).
        :return: True if the point is within the world, False otherwise.
        """
        return (self.get_xmin() <= p[0] < self.get_xmax() and
                self.get_ymin() <= p[1] < self.get_ymax() and
                self.get_zmin() <= p[2] < self.get_zmax())

    def is_blocked(self, p):
        """
        Determines if a point is inside an obstacle.
        :param p: A tuple (x, y, z).
        :return: True if the point is within an obstacle in the world, False otherwise.
        """
        for obstacle in self.obstacles:
            if obstacle.inside(p):
                return True
        return False

    def is_valid(self, p):
        """
        Determines if a point is valid such that it is in bounds and outside an obstacle.
        :param p: A tuple (x, y, z).
        :return: True if the point is valid, False otherwise.
        """
        return self.in_bounds(p) and not self.is_blocked(p)

    def is_traversable(self, p):
        """
        Determines whether a point can be traversed or not. This is distinct from is_walkalbe as this checks whether
            a point falls on top of an obstacle or not.
        :param p: A tuple (x, y, z).
        :return: True if the point is traversable, False otherwise.
        """
        for obstacle in self.obstacles:
            if obstacle.ontop(p):
                return True
        return False

    def is_walkable(self, p):
        """
        Determines if a point is walkable or not.
        :param p: A tuple (x, y, z).
        :return: True if the point is walkable, False otherwise.
        """
        if p[1] in self.walkable.keys():
            for q in self.walkable[p[1]]:
                if (q[0] < p[0] < q[0] + 1 and
                        q[1] < p[2] < q[1] + 1):
                    return True
        return False


def malmo():
    # Create default Malmo objects:
    agent_host = MalmoPython.AgentHost()

    try:
        agent_host.parse(sys.argv)
    except RuntimeError as e:
        print 'ERROR:', e
        print agent_host.getUsage()
        exit(1)
    if agent_host.receivedArgument("help"):
        print agent_host.getUsage()
        exit(0)

    if agent_host.receivedArgument("test"):
        num_repeats = 1
    else:
        num_repeats = 10

    for i in range(len(mission_files)):
        # Attempt to start a mission:
        my_mission = MalmoPython.MissionSpec(open(mission_files[i], 'r').read(), False)
        planner = Agent(mission_start, mission_goal[i])
        planner.create_world((mission_lower_bounds[i][0], mission_upper_bounds[i][0]),
                             (mission_lower_bounds[i][1], mission_upper_bounds[i][1]),
                             (mission_lower_bounds[i][2], mission_upper_bounds[i][2]),
                             mission_text_files[i])
        path = planner.explore_rrt()
        print path

        max_retries = 3
        for retry in range(max_retries):
            try:
                agent_host.startMission(my_mission, MalmoPython.MissionRecordSpec())
                break
            except RuntimeError as e:
                if retry == max_retries - 1:
                    print "Error starting mission:", e
                    exit(1)
                else:
                    time.sleep(2)

        # Loop until mission starts:
        print "Waiting for the mission to start ",
        world_state = agent_host.getWorldState()
        while not world_state.has_mission_begun:
            sys.stdout.write(".")
            time.sleep(0.1)
            world_state = agent_host.getWorldState()
            for error in world_state.errors:
                print "Error:", error.text

        print
        print "Mission running ",

        # Loop until mission ends:
        while world_state.is_mission_running:
            sys.stdout.write(".")
            time.sleep(0.1)
            world_state = agent_host.getWorldState()
            if path:
                position = path.pop()
                agent_host.sendCommand("tp {0} {1} {2}".format(*position))

        print
        print "Mission ended"
        # Mission has ended.

        #msg = world_state.observations[-1].text
        #obs = json.loads(msg)
        #print obs.get(u'XPos'), obs.get(u'YPos'), obs.get(u'ZPos')

if __name__ == '__main__':
    malmo()